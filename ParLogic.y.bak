-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParLogic where
import AbsLogic
import LexLogic
import ErrM

}

%name pExp Exp
%name pExp1 Exp1
%name pExp2 Exp2
%name pExp3 Exp3
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '<=>' { PT _ (TS _ 3) }
  '=>' { PT _ (TS _ 4) }
  '^' { PT _ (TS _ 5) }
  'a' { PT _ (TS _ 6) }
  'b' { PT _ (TS _ 7) }
  'c' { PT _ (TS _ 8) }
  'd' { PT _ (TS _ 9) }
  'e' { PT _ (TS _ 10) }
  'f' { PT _ (TS _ 11) }
  'g' { PT _ (TS _ 12) }
  'h' { PT _ (TS _ 13) }
  'i' { PT _ (TS _ 14) }
  'j' { PT _ (TS _ 15) }
  'k' { PT _ (TS _ 16) }
  'l' { PT _ (TS _ 17) }
  'm' { PT _ (TS _ 18) }
  'n' { PT _ (TS _ 19) }
  'o' { PT _ (TS _ 20) }
  'p' { PT _ (TS _ 21) }
  'r' { PT _ (TS _ 22) }
  's' { PT _ (TS _ 23) }
  't' { PT _ (TS _ 24) }
  'u' { PT _ (TS _ 25) }
  'v' { PT _ (TS _ 26) }
  'w' { PT _ (TS _ 27) }
  'x' { PT _ (TS _ 28) }
  'y' { PT _ (TS _ 29) }
  'z' { PT _ (TS _ 30) }
  '~' { PT _ (TS _ 31) }



%%


Exp :: { Exp }
Exp : Exp '=>' Exp1 { AbsLogic.EImp $1 $3 }
    | Exp '<=>' Exp1 { AbsLogic.EEq $1 $3 }
    | Exp1 { $1 }
Exp1 :: { Exp }
Exp1 : Exp1 '^' Exp2 { AbsLogic.EAnd $1 $3 }
     | Exp1 'v' Exp2 { AbsLogic.EOr $1 $3 }
     | Exp2 { $1 }
Exp2 :: { Exp }
Exp2 : '~' Exp3 { AbsLogic.ENot $2 } | Exp3 { $1 }
Exp3 :: { Exp }
Exp3 : 'a' { AbsLogic.EVar_a }
     | 'b' { AbsLogic.EVar_b }
     | 'c' { AbsLogic.EVar_c }
     | 'd' { AbsLogic.EVar_d }
     | 'e' { AbsLogic.EVar_e }
     | 'f' { AbsLogic.EVar_f }
     | 'g' { AbsLogic.EVar_g }
     | 'h' { AbsLogic.EVar_h }
     | 'i' { AbsLogic.EVar_i }
     | 'j' { AbsLogic.EVar_j }
     | 'k' { AbsLogic.EVar_k }
     | 'l' { AbsLogic.EVar_l }
     | 'm' { AbsLogic.EVar_m }
     | 'n' { AbsLogic.EVar_n }
     | 'o' { AbsLogic.EVar_o }
     | 'p' { AbsLogic.EVar_p }
     | 'r' { AbsLogic.EVar_r }
     | 's' { AbsLogic.EVar_s }
     | 't' { AbsLogic.EVar_t }
     | 'u' { AbsLogic.EVar_u }
     | 'w' { AbsLogic.EVar_w }
     | 'y' { AbsLogic.EVar_y }
     | 'z' { AbsLogic.EVar_z }
     | 'x' { AbsLogic.EVar_x }
     | '(' Exp ')' { $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

